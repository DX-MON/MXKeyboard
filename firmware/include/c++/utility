// SPDX-License-Identifier: BSD-3-Clause
#ifndef UTILITY
#define UTILITY

#include <type_traits>

namespace std
{
	template<typename T> constexpr T&& forward(typename std::remove_reference<T>::type &t) noexcept
		{ return static_cast<T &&>(t); }

	template<typename T> constexpr T&& forward(typename std::remove_reference<T>::type &&t) noexcept
	{
		//static_assert(!std::is_lvalue_reference<T>::value, "template argument subtituting T "
		//	"is an lvalue reference type");
		return static_cast<T &&>(t);
	}

	template<typename> struct tuple_size;

	namespace impl
	{
		template<typename T, typename U = remove_cv_t<T>, typename = enable_if_t<is_same_v<T, U>>,
			size_t = tuple_size<T>::value> using enable_if_has_tuple_size = T;
	} // namespace impl

	template<typename T> struct tuple_size<const impl::enable_if_has_tuple_size<T>> : public tuple_size<T> { };
	template<typename T> struct tuple_size<volatile impl::enable_if_has_tuple_size<T>> : public tuple_size<T> { };
	template<typename T> struct tuple_size<const volatile impl::enable_if_has_tuple_size<T>> : public tuple_size<T> { };

	template<std::size_t, typename> struct tuple_element;
	template<std::size_t i, typename T> using tuple_element_t = typename tuple_element<i, T>::type;

	template<std::size_t i, typename T> struct tuple_element<i, const T>
		{ using type = add_const_t<tuple_element_t<i, T>>; };
	template<std::size_t i, typename T> struct tuple_element<i, volatile T>
		{ using type = add_volatile_t<tuple_element_t<i, T>>; };
	template<std::size_t i, typename T> struct tuple_element<i, const volatile T>
		{ using type = add_cv_t<tuple_element_t<i, T>>; };

	template<typename T> constexpr remove_reference_t<T> &&move(T &&t) noexcept
		{ return static_cast<remove_reference_t<T> &&>(t); }

	template<typename T> constexpr inline /*enable_if_t<!is_tuple_like_v<T> && is_move_constructable_v<T> &&
		is_move_assignable_v<T>>*/void swap(T &a, T &b) noexcept(true)
	{
		T other{move(a)};
		a = move(b);
		b = move(other);
	}

} // namespace std

#endif /*UTILITY*/
