// SPDX-License-Identifier: BSD-3-Clause
#ifndef TYPE_TRAITS
#define TYPE_TRAITS

namespace std
{
	template<typename T, T v> struct integral_constant
	{
		using value_type = T;
		using type = integral_constant<T, v>;

		constexpr static T value = v;
		constexpr operator value_type() const noexcept { return value; }
		constexpr value_type operator ()() const noexcept { return value; }
	};

	template<typename T, T v> constexpr T integral_constant<T, v>::value;

	template<bool, typename T = void> struct enable_if { };
	template<typename T> struct enable_if<true, T> { using type = T; };
	template<bool cond, typename T = void> using enable_if_t = typename enable_if<cond, T>::type;

	using true_type = integral_constant<bool, true>;
	using false_type = integral_constant<bool, false>;
	template<bool value> using _bool_constant = integral_constant<bool, value>;

	namespace impl
	{
		template<typename T, typename U = T &&> U declval();
		template<typename T> T declval();
	}

	template<typename T> auto declval() noexcept -> decltype(impl::declval<T>());

	// impl for is_nothrow_swapable
	namespace impl
	{
		template<typename T> struct is_nothrow_swappable
		{
			template<typename U> static auto test() ->
				_bool_constant<noexcept(swap(std::declval<U &>(), std::declval<U &>()))>;
			template<typename> static false_type test();

			using type = decltype(test<T>());
		};
	} // namespace impl
	template<typename T> struct is_nothrow_swappable :
		impl::is_nothrow_swappable<T>::type { };

	template<typename T> constexpr inline bool is_nothrow_swappable_v = is_nothrow_swappable<T>::value;

	template<typename T> struct remove_cv { using type = T; };
	template<typename T> struct remove_cv<const T> { using type = T; };
	template<typename T> struct remove_cv<volatile T> { using type = T; };
	template<typename T> struct remove_cv<const volatile T> { using type = T; };

	template<typename T> struct remove_reference { using type = T; };
	template<typename T> struct remove_reference<T &> { using type = T; };
	template<typename T> struct remove_reference<T &&> { using type = T; };

	template<typename T> using remove_cv_t = typename remove_cv<T>::type;
	template<typename T> using remove_reference_t = typename remove_reference<T>::type;

	// impl for is_integral
	namespace impl
	{
		template<typename> struct is_integral : public false_type { };
		template<> struct is_integral<bool> : public true_type { };
		template<> struct is_integral<char> : public true_type { };
		template<> struct is_integral<signed char> : public true_type { };
		template<> struct is_integral<unsigned char> : public true_type { };
		template<> struct is_integral<char16_t> : public true_type { };
		template<> struct is_integral<char32_t> : public true_type { };
		template<> struct is_integral<short> : public true_type { };
		template<> struct is_integral<unsigned short> : public true_type { };
		template<> struct is_integral<int> : public true_type { };
		template<> struct is_integral<unsigned int> : public true_type { };
		template<> struct is_integral<long> : public true_type { };
		template<> struct is_integral<unsigned long> : public true_type { };
		template<> struct is_integral<long long> : public true_type { };
		template<> struct is_integral<unsigned long long> : public true_type { };
	} // namespace impl

	template<typename T> struct is_integral : impl::is_integral<remove_cv_t<T>>::type { };
	template<typename T> inline constexpr bool is_integral_v = is_integral<T>::value;

	// impl for is_signed
	namespace impl
	{
		// Should be is_arithmetic, but..
		template<typename T, bool = is_integral<T>::value> struct is_signed : false_type { };
		template<typename T> struct is_signed<T, true> : public _bool_constant<T(-1) < T(0)> { };
	} // namespace impl

	template<typename T> struct is_signed : impl::is_signed<T>::type { };
	template<typename T> inline constexpr bool is_signed_v = is_signed<T>::value;

	constexpr bool is_constant_evaluated() noexcept
	{
#if defined(__GNUC__)
		return __builtin_is_constant_evaluated();
#else
		return false;
#endif
	}
} // namespace std

#endif /*TYPE_TRAITS*/
